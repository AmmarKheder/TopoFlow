"""
V√©rifier si le bloc 0 dans le checkpoint est diff√©rent des autres blocs
et si le mod√®le actuel a la m√™me structure
"""
import torch
import sys
sys.path.insert(0, 'src')
import yaml

print("="*100)
print("üîç COMPARAISON: Bloc 0 du checkpoint vs mod√®le actuel")
print("="*100)

# Load checkpoint
ckpt_path = "logs/multipollutants_climax_ddp/version_47/checkpoints/best-val_loss_val_loss=0.3557-step_step=311.ckpt"
ckpt = torch.load(ckpt_path, map_location='cpu', weights_only=False)
state_dict = ckpt['state_dict']

# Fix prefix
ckpt_keys = {}
for key, value in state_dict.items():
    if key.startswith('model.'):
        ckpt_keys[key[6:]] = value
    else:
        ckpt_keys[key] = value

# Get all block 0 attention keys
print("\n1Ô∏è‚É£ CHECKPOINT - Bloc 0 attention keys:")
print("-" * 100)
block0_keys = sorted([k for k in ckpt_keys.keys() if 'blocks.0.attn' in k])
for k in block0_keys:
    shape = ckpt_keys[k].shape if hasattr(ckpt_keys[k], 'shape') else 'scalar'
    print(f"   {k:60s} {shape}")

# Get all block 1 attention keys for comparison
print("\n2Ô∏è‚É£ CHECKPOINT - Bloc 1 attention keys (pour comparaison):")
print("-" * 100)
block1_keys = sorted([k for k in ckpt_keys.keys() if 'blocks.1.attn' in k])
for k in block1_keys:
    shape = ckpt_keys[k].shape if hasattr(ckpt_keys[k], 'shape') else 'scalar'
    print(f"   {k:60s} {shape}")

# Compare structures
print("\n3Ô∏è‚É£ COMPARAISON:")
print("-" * 100)
print(f"   Bloc 0 a {len(block0_keys)} cl√©s")
print(f"   Bloc 1 a {len(block1_keys)} cl√©s")

if len(block0_keys) == len(block1_keys):
    print(f"   ‚úÖ M√™me nombre de cl√©s")
else:
    print(f"   ‚ö†Ô∏è  Nombre de cl√©s diff√©rent!")

    # Find differences
    block0_set = set([k.replace('blocks.0', 'blocks.X') for k in block0_keys])
    block1_set = set([k.replace('blocks.1', 'blocks.X') for k in block1_keys])

    only_in_0 = block0_set - block1_set
    only_in_1 = block1_set - block0_set

    if only_in_0:
        print(f"\n   ‚ö†Ô∏è  Cl√©s seulement dans bloc 0:")
        for k in sorted(only_in_0):
            print(f"      {k}")

    if only_in_1:
        print(f"\n   ‚ö†Ô∏è  Cl√©s seulement dans bloc 1:")
        for k in sorted(only_in_1):
            print(f"      {k}")

# Now check current model
print("\n4Ô∏è‚É£ MOD√àLE ACTUEL - Bloc 0:")
print("-" * 100)

from model_multipollutants import MultiPollutantModel
with open('configs/config_all_pollutants.yaml', 'r') as f:
    config = yaml.safe_load(f)

model = MultiPollutantModel(config)
model_params = dict(model.named_parameters())

model_block0_keys = sorted([k for k in model_params.keys() if 'blocks.0.attn' in k])
for k in model_block0_keys:
    shape = model_params[k].shape
    print(f"   {k:60s} {shape}")

print("\n5Ô∏è‚É£ MOD√àLE ACTUEL - Bloc 1 (pour comparaison):")
print("-" * 100)
model_block1_keys = sorted([k for k in model_params.keys() if 'blocks.1.attn' in k])
for k in model_block1_keys:
    shape = model_params[k].shape
    print(f"   {k:60s} {shape}")

print("\n6Ô∏è‚É£ COMPARAISON MOD√àLE ACTUEL:")
print("-" * 100)
print(f"   Bloc 0 a {len(model_block0_keys)} cl√©s")
print(f"   Bloc 1 a {len(model_block1_keys)} cl√©s")

if len(model_block0_keys) == len(model_block1_keys):
    print(f"   ‚úÖ M√™me nombre de cl√©s dans le mod√®le actuel")
else:
    print(f"   ‚ùå PROBL√àME: Bloc 0 diff√©rent du bloc 1 dans le mod√®le actuel!")

    # Find differences
    model_block0_set = set([k.replace('blocks.0', 'blocks.X') for k in model_block0_keys])
    model_block1_set = set([k.replace('blocks.1', 'blocks.X') for k in model_block1_keys])

    only_in_model_0 = model_block0_set - model_block1_set
    only_in_model_1 = model_block1_set - model_block0_set

    if only_in_model_0:
        print(f"\n   ‚ö†Ô∏è  Cl√©s seulement dans bloc 0 du mod√®le actuel:")
        for k in sorted(only_in_model_0):
            print(f"      {k}")

    if only_in_model_1:
        print(f"\n   ‚ö†Ô∏è  Cl√©s seulement dans bloc 1 du mod√®le actuel:")
        for k in sorted(only_in_model_1):
            print(f"      {k}")

print("\n7Ô∏è‚É£ ANALYSE FINALE:")
print("-" * 100)

# Check if checkpoint block 0 matches model block 0
ckpt_block0_normalized = set([k.replace('blocks.0', 'blocks.X') for k in block0_keys])
model_block0_normalized = set([k.replace('climax.blocks.0', 'blocks.X').replace('blocks.0', 'blocks.X') for k in model_block0_keys])

if ckpt_block0_normalized == model_block0_normalized:
    print("   ‚úÖ Le bloc 0 du checkpoint MATCH le bloc 0 du mod√®le actuel")
    print("   ‚úÖ Architecture compatible!")
else:
    print("   ‚ùå INCOMPATIBILIT√â: Le bloc 0 du checkpoint NE MATCH PAS le mod√®le actuel!")

    only_in_ckpt_block0 = ckpt_block0_normalized - model_block0_normalized
    only_in_model_block0 = model_block0_normalized - ckpt_block0_normalized

    if only_in_ckpt_block0:
        print(f"\n   Cl√©s dans checkpoint bloc 0 mais pas dans mod√®le:")
        for k in sorted(only_in_ckpt_block0):
            print(f"      {k}")

    if only_in_model_block0:
        print(f"\n   Cl√©s dans mod√®le bloc 0 mais pas dans checkpoint:")
        for k in sorted(only_in_model_block0):
            print(f"      {k}")

    print("\n   üö® PROBL√àME: Le mod√®le actuel a une architecture TopoFlow m√™me avec use_physics_mask=false!")
    print("   üìù ACTION REQUISE: V√©rifier climax.py pour voir comment le bloc 0 est cr√©√©")

print("="*100)
